#!@PYTHON@
# Copyright 2020 gi-lom
# Copyright 2020 Nikita Kravets
# Copyright 2020-2022 Rafael Mardojai CM
# Copyright 2021-2022 Mufeed Ali
# SPDX-License-Identifier: GPL-3.0-or-later

import logging
from gettext import gettext as _

import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GLib

from dialect.session import Session, ResponseError
from dialect.settings import Settings
from dialect.translators import get_lang_name, TRANSLATORS
from dialect.translators.basetrans import ApiKeyRequired, InvalidApiKey

search_bus_name = 'org.gnome.Shell.SearchProvider2'
sbn = dict(dbus_interface=search_bus_name)


class TranslateService(dbus.service.Object):
    bus_name = '@APP_ID@.SearchProvider'
    _object_path = '@object_path@'

    def __init__(self):
        # init dbus
        self.session_bus = dbus.SessionBus()
        bus_name = dbus.service.BusName(self.bus_name, bus=self.session_bus)
        dbus.service.Object.__init__(self, bus_name, self._object_path)

        self.live_enabled = False

        # Translations running now
        self.translations = dict()
        Settings.get().connect('changed', self._on_settings_changed)

        self.dest_language = None
        self.ongoing_trans = False
        self.next_trans = {}

        self.translator = self._get_translator()

    @dbus.service.method(in_signature='as', out_signature='as', **sbn)
    def GetInitialResultSet(self, terms):
        """
        Join separate terms in one ID line, start translation and send this line back
        on start of input
        """
        self.live_enabled = self.is_live_enabled()
        backend = Settings.get().active_translator
        text = ' '.join(terms)
        if self.live_enabled:
            self.translation(text)
        else:
            self.translations[text] = _(f'Translate “{text}” with {TRANSLATORS[backend].prettyname}')
        return [text]

    @dbus.service.method(in_signature='as', out_signature='aa{sv}', **sbn)
    def GetResultMetas(self, ids):
        """Send translated text"""
        translate_id = ids[0]

        # wait for the translation to finish
        if translate_id in self.translations:
            while self.translations[translate_id] == '':
                pass

            name = self.translations[translate_id]
            lang = get_lang_name(self.dest_language)
            self.translations.clear()

            return [
                dict(
                    id=id,
                    name=name,
                    description=lang or '',
                )
                for id in ids
            ]

        # if there is no translation of this text send the original text
        return [
            dict(
                id=id,
                name=id,
            )
            for id in ids
        ]

    @dbus.service.method(in_signature='asas', out_signature='as', **sbn)
    def GetSubsearchResultSet(self, previous_results, new_terms):
        """
        Join separate terms in one ID line, start translation and send this line back
        on update of text
        """
        backend = Settings.get().active_translator
        text = ' '.join(new_terms)
        if self.live_enabled:
            self.translation(text)
        else:
            self.translations[text] = _(f'Translate “{text}” with {TRANSLATORS[backend].prettyname}')
        return [text]

    @dbus.service.method(in_signature='sasu', **sbn)
    def ActivateResult(self, id, terms, timestamp):
        text = ' '.join(terms)
        GLib.spawn_async_with_pipes(
            None, ['@BIN@', '--text', text], None,
            GLib.SpawnFlags.SEARCH_PATH, None
        )

    @dbus.service.method(in_signature='asu', terms='as', timestamp='u', **sbn)
    def LaunchSearch(self, terms, timestamp):
        text = ' '.join(terms)
        GLib.spawn_async_with_pipes(
            None, ['@BIN@', '--text', text], None,
            GLib.SpawnFlags.SEARCH_PATH, None
        )

    def translation(self, src_text=None):
        """Start a new translation"""
        src_language = 'auto'
        src_language_saved = Settings.get().src_langs[0]
        self.dest_language = Settings.get().dest_langs[0]

        if self.ongoing_trans:
            self.next_trans = {
                'text': src_text,
                'src': src_language,
                'src-saved': src_language_saved,
                'dest': self.dest_language
            }
            return

        if self.next_trans:
            src_text = self.next_trans['text']
            src_language = self.next_trans['src']
            src_language_saved = self.next_trans['src-saved']
            self.dest_language = self.next_trans['dest']
            self.next_trans = {}

        self.translations[src_text] = ''

        # If the two languages are the same, nothing is done
        if src_language != self.dest_language and src_text != '':
            self.ongoing_trans = True

            # Format data
            url = self.translator.translate_url.format(
                text=src_text, src=src_language, dest=self.dest_language
            )
            (method, data, headers, raw) = self.translator.format_translation(
                src_text, src_language, self.dest_language
            )

            message = Session.create_message(method, url, data, headers, raw)

            Session.get().send_and_read_async(
                message,
                0,
                None,
                self.on_translation_response,
                (src_text, raw)
            )

    def on_translation_response(self, session, result, original):
        try:
            data = Session.get_response(session, result, raw=original[3])
            (translation, _lang) = self.translator.get_translation(data)
            self.translations[original[0]] = translation.text
        except ResponseError as exc:
            logging.error(exc)
            self.translations[original[0]] = _('Translation failed, check for network issues')
        except InvalidApiKey as exc:
            logging.error(exc)
            self.translations[original[0]] = _('The provided API key is invalid')
        except ApiKeyRequired as exc:
            logging.error(exc)
            self.translations[original[0]] = _('API key is required to use the service')
        except Exception as exc:
            logging.error(exc)

        self.ongoing_trans = False
        if self.next_trans:
            self.translation()

    def is_live_enabled(self):
        return Settings.get().live_translation and Settings.get().sp_translation

    def _get_translator(self):
        backend = Settings.get().active_translator
        if TRANSLATORS[backend].supported_features['change-instance']:
            translator = TRANSLATORS[backend](
                base_url=Settings.get().instance_url
            )
        else:
            translator = TRANSLATORS[backend]()
        return translator

    def _on_settings_changed(self, _settings, key):
        if key.startswith('translator-'):
            self.translator = self._get_translator()


if __name__ == "__main__":
    DBusGMainLoop(set_as_default=True)
    TranslateService()
    GLib.MainLoop().run()
