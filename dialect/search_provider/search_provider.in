#!@PYTHON@
# Copyright 2020 gi-lom
# Copyright 2020 Nikita Kravets
# Copyright 2020-2022 Rafael Mardojai CM
# Copyright 2021-2022 Mufeed Ali
# SPDX-License-Identifier: GPL-3.0-or-later

import logging
from gettext import gettext as _

import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GLib

from dialect.session import Session, ResponseError
from dialect.settings import Settings
from dialect.translators import TRANSLATORS
from dialect.translators.basetrans import ApiKeyRequired, InvalidApiKey

APP_ID = 'app.drey.Dialect'

search_bus_name = 'org.gnome.Shell.SearchProvider2'
sbn = dict(dbus_interface=search_bus_name)


class TranslateService(dbus.service.Object):
    bus_name = 'app.drey.Dialect.SearchProvider'
    _object_path = '/' + bus_name.replace('.', '/')

    def __init__(self):
        # init dbus
        self.session_bus = dbus.SessionBus()
        bus_name = dbus.service.BusName(self.bus_name, bus=self.session_bus)
        dbus.service.Object.__init__(self, bus_name, self._object_path)

        self.live_enabled = False

        # Translations running now
        self.translations = dict()
        Settings.get().connect('changed', self._on_settings_changed)

        self.dest_language = None
        self.ongoing_trans = False
        self.next_trans = {}

        self.translator = self._get_translator()

    @dbus.service.method(in_signature='as', out_signature='as', **sbn)
    def GetInitialResultSet(self, terms):
        """
        Join separate terms in one ID line, start translation and send this line back
        on start of input
        """
        self.live_enabled = self.is_live_enabled()
        text = ' '.join(terms)
        if self.live_enabled:
            self.translation(text)
        else:
            self.translations[text] = _(f'Translate “{text}” with {Settings.get().active_translator.prettyname}')
        return [text]

    @dbus.service.method(in_signature='as', out_signature='aa{sv}', **sbn)
    def GetResultMetas(self, ids):
        """Send translated text"""
        translate_id = ids[0]

        # wait for the translation to finish
        if translate_id in self.translations:
            while self.translations[translate_id] == '':
                pass

            name = self.translations[translate_id]
            lang = self.translator.languages[self.dest_language].capitalize()
            self.translations.clear()

            return [
                dict(
                    id=id,
                    name=name,
                    description=lang or '',
                )
                for id in ids
            ]

        # if there is no translation of this text send the original text
        return [
            dict(
                id=id,
                name=id,
            )
            for id in ids
        ]

    @dbus.service.method(in_signature='asas', out_signature='as', **sbn)
    def GetSubsearchResultSet(self, previous_results, new_terms):
        """
        Join separate terms in one ID line, start translation and send this line back
        on update of text
        """
        text = ' '.join(new_terms)
        if self.live_enabled:
            self.translation(text)
        else:
            self.translations[text] = _(f'Translate “{text}” with {Settings.get().active_translator.prettyname}')
        return [text]

    @dbus.service.method(in_signature='sasu', **sbn)
    def ActivateResult(self, id, terms, timestamp):
        text = ' '.join(terms)
        GLib.spawn_async_with_pipes(
            None, ['@BIN@', '--text', text], None,
            GLib.SpawnFlags.SEARCH_PATH, None
        )

    @dbus.service.method(in_signature='asu', terms='as', timestamp='u', **sbn)
    def LaunchSearch(self, terms, timestamp):
        text = ' '.join(terms)
        GLib.spawn_async_with_pipes(
            None, ['@BIN@', '--text', text], None,
            GLib.SpawnFlags.SEARCH_PATH, None
        )

    def translation(self, src_text=None):
        """Start a new translation"""
        src_language = 'auto'
        src_language_saved = Settings.get().src_langs[0]
        self.dest_language = Settings.get().dest_langs[0]

        if self.ongoing_trans:
            self.next_trans = {
                'text': src_text,
                'src': src_language,
                'src-saved': src_language_saved,
                'dest': self.dest_language
            }
            return

        if self.next_trans:
            src_text = self.next_trans['text']
            src_language = self.next_trans['src']
            src_language_saved = self.next_trans['src-saved']
            self.dest_language = self.next_trans['dest']
            self.next_trans = {}

        self.translations[src_text] = ''

        # If the two languages are the same, nothing is done
        if src_language != self.dest_language and src_text != '':
            self.ongoing_trans = True

            # Format data
            url = self.translator.translate_url.format(
                text=src_text, src=src_language, dest=self.dest_language
            )
            (method, data, headers, raw) = self.translator.format_translation(
                src_text, src_language, self.dest_language
            )

            message = Session.create_message(method, url, data, headers, raw)

            Session.get().send_and_read_async(
                message,
                0,
                None,
                self.on_translation_response,
                (src_text, raw)
            )

    def on_translation_response(self, session, result, original):
        try:
            data = Session.get_response(session, result, raw=original[3])
            (translation, _lang) = self.translator.get_translation(data)
            self.translations[original[0]] = translation.text
        except ResponseError as exc:
            logging.error(exc)
            self.translations[original[0]] = _('Translation failed, check for network issues')
        except InvalidApiKey as exc:
            logging.error(exc)
            self.translations[original[0]] = _('The provided API key is invalid')
        except ApiKeyRequired as exc:
            logging.error(exc)
            self.translations[original[0]] = _('API key is required to use the service')
        except Exception as exc:
            logging.error(exc)

        self.ongoing_trans = False
        if self.next_trans:
            self.translation()

    def is_live_enabled(self):
        return Settings.get().live_translation

    def _get_translator(self):
        backend = Settings.get().active_translator
        if TRANSLATORS[backend].supported_features['change-instance']:
            translator = TRANSLATORS[backend](
                base_url=Settings.get().instance_url
            )
        else:
            translator = TRANSLATORS[backend]()
        return translator

    def _on_settings_changed(self, _settings, key):
        if key.startswith('translator-'):
            self.translator = self._get_translator()


if __name__ == "__main__":
    DBusGMainLoop(set_as_default=True)
    TranslateService()
    GLib.MainLoop().run()
